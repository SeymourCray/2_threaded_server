<!----- Conversion time: 0.718 seconds.
Using this Markdown file:

1. Cut and paste this output into your source file.
2. See the notes and action items below regarding this conversion run.
3. Check the rendered output (headings, lists, code blocks, tables) for proper
   formatting and use a linkchecker before you publish this page.

Conversion notes:

* Docs to Markdown version 1.0β17
* Wed Sep 18 2019 01:52:00 GMT-0700 (PDT)
* Source doc: https://docs.google.com/open?id=1SEODmwLcgVdQijJMZ6Xc3YQ0lqnkc72w-gccG4AkpqU
----->

## Практикум

### Цель работы

Познакомиться с приемами работы с многопоточностью на примере создания сокетного TCP-сервера, способного работать с несколькими клиентами одновременно

### Контрольные вопросы

1. Почему однопоточное приложение не может решить задачу одновременного подключения? Потому что программа будет занята либо обслуживанием уже подключившегося пользователя, либо будет принимать соединение от нового. Иначе говоря, в один момент времени программа выполняет только одно "действие".

2. Чем поток отличается от процесса?Процессы и потоки связаны друг с другом, но при этом имеют существенные различия. Процесс — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого. Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры, файлы, каналы связи между компьютерами и многое другое. Поток использует то же самое пространства стека, что и процесс, а множество потоков совместно используют данные своих состояний. Как правило, каждый поток может работать (читать и писать) с одной и той же областью памяти, в отличие от процессов, которые не могут просто так получить доступ к памяти другого процесса. У каждого потока есть собственные регистры и собственный стек, но другие потоки могут их использовать. Поток — определенный способ выполнения процесса. Когда один поток изменяет ресурс процесса, это изменение сразу же становится видно другим потокам этого процесса.

3. Как создать новый поток? 
4. Как выделить участок кода так, чтобы он выполнялся в другом потоке?

![image](https://user-images.githubusercontent.com/70951761/139743420-1e96b126-380e-420f-bc33-cca5bea296b4.png)
![image](https://user-images.githubusercontent.com/70951761/139743537-e102fe49-1b10-4a05-8c8f-7c00ddd3c234.png)

5. В чем проблема потокобезопасности?С точки зрения безопасности, почему мы заботимся о безопасности потоков? Потому что у безопасности памяти и потоков одна и та же основная проблема: недопустимое использование ресурсов. Здесь атаки приводят к таким же последствиям, как атаки на память, включая повышение привилегий, выполнение произвольного кода (ACE) и обход проверок безопасности.

6. Какие методы обеспечения потокобезопасности существуют?Класс является потокобезопасным, если он ведет себя правильно при доступе из нескольких потоков, независимо от планирования или чередования выполнения этих потоков средой выполнения, и без дополнительной синхронизации или другой координации со стороны вызывающего кода. Простейший способ синхронизации с общими переменными или другими ресурсами, это положиться на атомарные операции в интерпретаторе. Атомарная операция – это операция, которая осуществляет только один этап выполнения задачи, без каких либо шансов того, что другой поток получит контроль.Блокировки – это фундаментальный механизм синхронизации, который предоставлен модулем threading Python. Замок может удерживаться одним потоком в любое время, или без потока вообще. Если поток попытается удержать один замок, который уже удерживается другим потоком, выполнение первого потока будет остановлена, пока не будет снята блокировка. Замки обычно используются для синхронизации доступа к общим ресурсам. Для каждого такого источника создается объект Lock.Класс RLock – это версия замка, который выполняет функцию блокировки только в том случае, если замок удерживает другой поток. В то время как обычные замки блокируют тогда, когда тот же поток пытается получить к одному и тому же замку дважды, реентерабельный замок блокирует только в том случае, если другой поток уже держит замок.Семафор — это более продвинутый механизм блокировки. В семафоре есть внутренний счетчик, вместо флага блокировки, и блокирует он только в том случае, если большее количество потоков (чем указано) попытается удержать семафор. В зависимости от того, как инициализирован семафор, это позволяет нескольким потокам получить доступ к одной и той же части кода одновременно.Объект event – это простой объект синхронизации. Он представляет собой внутренний флаг, так что все потоки могут ожидать, пока флаг будет установлен, задавать, или убирать его.Объект condition это более продвинутая версия объекта event. Он представляет собой своего рода измененное состояние в приложении, и поток может дожидаться заданных условий, или сигнал о том, что условие было задано.

### Дополнительные задания

1. Модифицировать простой эхо-сервер таким образом, чтобы при подключении клиента создавался новый поток, в котором происходило взаимодействие с ним.

![image](https://user-images.githubusercontent.com/70951761/139740480-951ee723-f981-44bf-adcf-393fcfe55ddd.png)

2. Реализовать простой чат сервер на базе сервера аутентификации. Сервер должен обеспечивать подключение многих пользователей одновременно, отслеживание имен пользователей, поддерживать историю сообщений и пересылку сообщений от каждого пользователя всем остальным. 

![image](https://user-images.githubusercontent.com/70951761/139741230-384fc346-ea73-4d04-9347-51243f7b0f96.png)

3. Реализовать сервер с управляющим потоком. При создании сервера прослушивание портов происходит в отдельном потоке, а главный поток программы в это время способен принимать команды от пользователя. Необходимо реализовать следующие команды:
    1. Отключение сервера (завершение программы);
    2. Пауза (остановка прослушивание порта);
    3. Показ логов;
    4. Очистка логов;
    5. Очистка файла идентификации.
 
![image](https://user-images.githubusercontent.com/70951761/139742471-7aee23b3-e1e7-4b28-bf6d-4b56c8018156.png)
![image](https://user-images.githubusercontent.com/70951761/139742507-4987f562-8fd5-40a4-ad15-d1b903b8fe33.png)

<!-- Docs to Markdown version 1.0β17 -->
